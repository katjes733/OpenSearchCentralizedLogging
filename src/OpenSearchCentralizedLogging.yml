# MIT License
# 
# Copyright (c) 2021 Martin Macecek
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

AWSTemplateFormatVersion: 2010-09-09
Description: Simple Centralized Logging

# -----------------------------------------------------------------------------
# Parameters
# -----------------------------------------------------------------------------
Parameters:
  ResourcePrefix:
    Description: The prefix for all resources. If empty, auto generated by AWS including the name of the stack.
    Type: String
    Default: ''
    AllowedPattern: ^$|^[a-z0-9-]{0,7}$
  OpenSearchName:
    Description: Name of the OpenSearch Domain. Also used as subdomain Custom OpenSearch Dashboards
    Type: String
    Default: cwl
  CustomOpenSearchDashboardsDomain:
    Description: Domain for the Custom OpenSearch Dashboards
    Type: String
  AdminEmail:
    Description: The email address of the admin account
    Type: String
    Default: admin@domain.com
    AllowedPattern: '^[\w\.]+\@[\w]+\.[a-z]+$'
  Size:
    Description: OpenSearch size; S (4 data nodes), M (6 data nodes), L (6 data nodes)
    Type: String
    Default: XS
    AllowedValues:
      - XS
      - S
      - M
      - L
  MultiAz:
    Type: String
    Description: Whether or not to use Multi AZ
    Default: 'false'
    AllowedValues:
      - 'true'
      - 'false'
  SpokeRegions:
    Type: String
    Description: The comma separated list of regions to be supported. Leave empty for all regions.
    AllowedPattern: '^$|^[a-z]{2}-(?:gov-){0,1}(?:north|northeast|east|southeast|south|southwest|west|northwest|central)-[1-9]{1}(?:,[a-z]{2}-(?:gov-){0,1}(?:north|northeast|east|southeast|south|southwest|west|northwest|central)-[1-9]{1})*$'
  SpokeAccounts:
    Type: String
    Description: The comma separated list of accounts that may deliver logs. Leave empty for current account only.
    AllowedPattern: '^$|^\d{12}(?:,\d{12})*$'
  DestinationName:
    Type: String
    Description: The name of the destination for each region
    Default: 'Central-CloudWatch-Logging'
    AllowedPattern: '^[^:*]*$'
  OpenSearchIndexName:
    Type: String
    Description: The name of the index in OpenSearch
    Default: 'cwl'
    AllowedPattern: '^[\w\-]{1,80}$'

# -----------------------------------------------------------------------------
# Mappings
# -----------------------------------------------------------------------------
Mappings:
  OpenSearchSizing:
    NodeCount:
      XS: 1
      S: 2
      M: 3
      L: 4
    MasterCount:
      XS: 0
      S: 1
      M: 2
      L: 3
    MasterSize:
      XS: NA
      S: c6g.large.search
      M: c6g.large.search
      L: c6g.large.search
    InstanceSize:
      XS: t3.small.search
      S: r6g.large.search
      M: r6g.2xlarge.search
      L: r6g.4xlarge.search

# -----------------------------------------------------------------------------
# Conditions
# -----------------------------------------------------------------------------
Conditions:
  UseMasterNode: !Not [!Equals [!FindInMap [OpenSearchSizing, MasterCount, !Ref Size], '0']]
  UseZoneAwarenes: !Equals [!Ref MultiAz, 'true']
  UseCurrentAccount: !Equals [!Ref SpokeAccounts, '']
  UseSpecificResourcePrefix: !Not [!Equals [!Ref ResourcePrefix, '']]

# -----------------------------------------------------------------------------
# Resources
# -----------------------------------------------------------------------------
Resources:
  DeploymentHelperRole:
    Type: 'AWS::IAM::Role'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28
            reason: "Only in case a specific resource prefix is used"
    Properties:
      RoleName: !If [UseSpecificResourcePrefix, !Sub '${ResourcePrefix}DeploymentHelperRole', !Ref AWS::NoValue]
      AssumeRolePolicyDocument:
        Statement:
          - Action: 'sts:AssumeRole'
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
        Version: 2012-10-17
      ManagedPolicyArns:
        - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
  DeploymentHelperRolePolicy:
    Type: 'AWS::IAM::Policy'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W12
            reason: '* needed, actions do not support resource level permissions'
    Properties:
      PolicyName: !Sub 
        - '${PolicyNamePrefix}DeploymentHelperRolePolicy'
        - { PolicyNamePrefix: !If [UseSpecificResourcePrefix, !Ref ResourcePrefix, !Ref AWS::StackName] }
      PolicyDocument:        
        Statement:    
          - Action:
              - 'ec2:DescribeRegions'
              - 'logs:PutDestination'
              - 'logs:DeleteDestination'
              - 'logs:PutDestinationPolicy'
            Effect: Allow
            Resource: '*'
          - Action:
              - 's3:Delete*'
              - 's3:Get*'
              - 's3:List*'
            Effect: Allow
            Resource:
              - 'arn:aws:s3:::*'
              - 'arn:aws:s3:::*/*'
          - Action: 'iam:CreateServiceLinkedRole'
            Condition:
              StringLike:
                'iam:AWSServiceName': es.amazonaws.com
            Effect: Allow
            Resource: !Sub 'arn:${AWS::Partition}:iam::*:role/aws-service-role/es.amazonaws.com/AWSServiceRoleForAmazonElasticsearchService*'
          - Action:
              - 'route53:ListHostedZonesByName'
            Effect: Allow                
            Resource: '*'
        Version: 2012-10-17      
      Roles:
        - !Ref DeploymentHelperRole
  DeploymentHelperLogGroup:
    Type: 'AWS::Logs::LogGroup'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "No critical data in logs"
    Properties:
      RetentionInDays: 1
      LogGroupName: !Sub 
        - '/aws/lambda/${LogGroupNamePrefix}DeploymentHelper'
        - { LogGroupNamePrefix: !If [UseSpecificResourcePrefix, !Ref ResourcePrefix, !Ref AWS::StackName] }
  DeploymentHelper:
    Type: AWS::Lambda::Function
    Metadata:
      cfn-lint:
        config:
          ignore_checks:
            - E3002
      cfn_nag:
        rules_to_suppress:
          - id: W58
            reason: "Provided by managed policy AWSLambdaBasicExecutionRole in DeploymentHelperRole"
          - id: W89
            reason: "No need for VPC here"
          - id: W92
            reason: "No concurrency needed"
    DependsOn: 
      - DeploymentHelperLogGroup
      - DeploymentHelperRolePolicy
    Properties: 
      FunctionName: !Sub 
        - '${FunctionNamePrefix}DeploymentHelper'
        - { FunctionNamePrefix: !If [UseSpecificResourcePrefix, !Ref ResourcePrefix, !Ref AWS::StackName] }
      Architectures: 
        - arm64
      Code: 
        ZipFile: |          
          import json, boto3, logging, time, os
          import cfnresponse

          levels = {
              'critical': logging.CRITICAL,
              'error': logging.ERROR,
              'warn': logging.WARNING,
              'info': logging.INFO,
              'debug': logging.DEBUG
          }
          logger = logging.getLogger()
          try:   
              logger.setLevel(levels.get(os.getenv('LOG_LEVEL', 'info').lower()))
          except KeyError as e:
              logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              logger.info(f"event: {event}")
              rp = event['ResourceProperties']
              rt = event['RequestType']
              rest = event['ResourceType']
              lri = event['LogicalResourceId']
              rv = {}
              try:
                  if rest == 'Custom::DeleteBucketContent':
                      delete_bucket_content(rp, rt)
                  elif rest == 'Custom::CloudWatchDestination':
                      cloudwatch_destinations(rp, rt)
                  elif rest == 'Custom::GetHostedZoneId':
                      rv = get_hosted_zone_id(rp, rt)
                  else:
                      logger.warn(f"No implementation for resourceType: {rest}")        
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, rv, lri)
              except Exception as e:
                  logger.error(f"Exception: {e}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, lri)

          def delete_bucket_content(rp, rt):    
              bucket = rp['BucketName']
              logger.debug(f"bucket: {bucket}, requestType: {rt}")
              if rt == 'Delete':
                  s3 = boto3.resource('s3')
                  bucket = s3.Bucket(bucket)
                  time.sleep(60)
                  bucket.objects.all().delete()
                  bucket.object_versions.all().delete()  

          def get_all_regions():
              return list(map(lambda e: e['RegionName'], filter(lambda e: e['RegionName'] != 'ap-northeast-3', boto3.client('ec2').describe_regions()['Regions'])))

          def delete_cloudwatch_destinations(destinationName, regions):
              for r in regions:
                  cw = boto3.client('logs', region_name=r)
                  try:
                      cw.delete_destination(destinationName=destinationName)
                  except cw.exceptions.ResourceNotFoundException as nf:
                      logger.debug(f"Destination {destinationName} does not exist in {r}.")

          def create_cloudwatch_destinations(regions, destinationName, roleArn, kinesisStreamArn, spokeAccounts):
              for r in regions:
                  cw = boto3.client('logs', region_name=r)
                  d = cw.put_destination(destinationName=destinationName, targetArn=kinesisStreamArn, roleArn=roleArn)['destination']
                  accessPolicy = {
                      'Version': '2012-10-17',
                      'Statement': [{
                          'Sid': 'AllowSpokesSubscribe',
                          'Effect': 'Allow',
                          'Principal': {
                              'AWS': spokeAccounts
                          },
                          'Action': 'logs:PutSubscriptionFilter',
                          'Resource': d['arn']
                      }]
                  }
                  cw.put_destination_policy(destinationName=destinationName, accessPolicy= json.dumps(accessPolicy))

          def cloudwatch_destinations(rp, rt):
              cw = boto3.client('logs')
              allRegions = get_all_regions()
              if rt == 'Create' or rt == 'Update':
                  regions = allRegions if rp['Regions'] else rp['Regions']
                  if all(r in regions for r in allRegions):    
                      delete_cloudwatch_destinations(rp['DestinationName'], regions)
                      create_cloudwatch_destinations(regions, rp['DestinationName'], rp['RoleArn'], rp['DataStreamArn'], rp['SpokeAccounts'])

              if rt == 'Delete':
                  delete_cloudwatch_destinations(rp['DestinationName'], allRegions)

          def get_hosted_zone_id(rp, rt):
              rv = {}
              if rt != 'Delete':
                  dn = rp['DnsName']
                  r53 = boto3.client('route53')
                  r = r53.list_hosted_zones_by_name(DNSName=dn)
                  hzi = r['HostedZones'][0]['Id'].split("/")[-1]
                  logger.debug(f"Hosted zone ID: {hzi}")
                  rv = {"HostedZoneId": hzi}
              return rv
      Description: OpenSearch - deployment helper functions
      Handler: "index.lambda_handler"
      Runtime: python3.8
      MemorySize: 128
      Timeout: 300
      Role: !GetAtt DeploymentHelperRole.Arn
      Environment:
        Variables:
          LOG_LEVEL: info
  OpenSearchCognitoUserPool:
    Type: 'AWS::Cognito::UserPool'
    Properties:
      UserPoolName: !Sub 
        - '${UserPoolNamePrefix}OpenSearchCognitoUserPool'
        - { UserPoolNamePrefix: !If [UseSpecificResourcePrefix, !Ref ResourcePrefix, !Ref AWS::StackName] }
      AccountRecoverySetting:
        RecoveryMechanisms:
          - Name: verified_email
            Priority: 1
      AdminCreateUserConfig:
        AllowAdminCreateUserOnly: true
      AutoVerifiedAttributes:
        - email
      EmailVerificationMessage: 'The verification code to your new account is {####}'
      EmailVerificationSubject: Verify your new account
      Policies:
        PasswordPolicy:
          MinimumLength: 8
          RequireLowercase: true
          RequireNumbers: true
          RequireSymbols: true
          RequireUppercase: true
          TemporaryPasswordValidityDays: 3
      Schema:
        - Mutable: true
          Name: email
          Required: true
      SmsVerificationMessage: 'The verification code to your new account is {####}'
      UsernameAttributes:
        - email
      UserPoolAddOns:
        AdvancedSecurityMode: ENFORCED
      VerificationMessageTemplate:
        DefaultEmailOption: CONFIRM_WITH_CODE
        EmailMessage: 'The verification code to your new account is {####}'
        EmailSubject: Verify your new account
        SmsMessage: 'The verification code to your new account is {####}'
  OpenSearchCognitoUserPoolDomain:
    Type: 'AWS::Cognito::UserPoolDomain'
    Properties:
      Domain: !Sub '${OpenSearchName}'
      UserPoolId: !Ref OpenSearchCognitoUserPool
  OpenSearchCognitoUserPoolAdminUser:
    Type: 'AWS::Cognito::UserPoolUser'
    Properties:
      UserPoolId: !Ref OpenSearchCognitoUserPool
      UserAttributes:
        - Name: email
          Value: !Ref AdminEmail
      Username: !Ref AdminEmail
  OpenSearchCognitoIdentityPool:
    Type: 'AWS::Cognito::IdentityPool'
    Properties:
      IdentityPoolName: !Sub 
        - '${IdentityPoolNamePrefix}OpenSearchCognitoIdentityPool'
        - { IdentityPoolNamePrefix: !If [UseSpecificResourcePrefix, !Ref ResourcePrefix, !Ref AWS::StackName] }
      AllowUnauthenticatedIdentities: false
  OpenSearchCognitoAuthenticationRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: 'sts:AssumeRoleWithWebIdentity'
            Condition:
              StringEquals:
                'cognito-identity.amazonaws.com:aud': !Ref OpenSearchCognitoIdentityPool
              'ForAnyValue:StringLike':
                'cognito-identity.amazonaws.com:amr': authenticated
            Effect: Allow
            Principal:
              Federated: cognito-identity.amazonaws.com
        Version: 2012-10-17
  OpenSearchCognitoIdentityPoolRoleAttachment:
    Type: 'AWS::Cognito::IdentityPoolRoleAttachment'
    Properties:
      IdentityPoolId: !Ref OpenSearchCognitoIdentityPool
      Roles:
        authenticated: !GetAtt OpenSearchCognitoAuthenticationRole.Arn
  OpenSearchCognitoRole:
    Type: 'AWS::IAM::Role'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: cognito actions do not allow resource level permissions
          - id: W28
            reason: "Only in case a specific resource prefix is used"
    Properties:
      RoleName: !If [UseSpecificResourcePrefix, !Sub '${ResourcePrefix}OpenSearchCognitoRole', !Ref AWS::NoValue]
      AssumeRolePolicyDocument:
        Statement:
          - Action: 'sts:AssumeRole'
            Effect: Allow
            Principal:
              Service: es.amazonaws.com
        Version: 2012-10-17
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - 'cognito-idp:DescribeUserPool'
                  - 'cognito-idp:CreateUserPoolClient'
                  - 'cognito-idp:DeleteUserPoolClient'
                  - 'cognito-idp:DescribeUserPoolClient'
                  - 'cognito-idp:AdminInitiateAuth'
                  - 'cognito-idp:AdminUserGlobalSignOut'
                  - 'cognito-idp:ListUserPoolClients'
                  - 'cognito-identity:DescribeIdentityPool'
                  - 'cognito-identity:UpdateIdentityPool'
                  - 'cognito-identity:SetIdentityPoolRoles'
                  - 'cognito-identity:GetIdentityPoolRoles'
                Effect: Allow
                Resource: '*'
            Version: 2012-10-17
          PolicyName: OpenSearchCognitoAccess
  OpenSearchCognitoRoleDefaultPolicy:
    Type: 'AWS::IAM::Policy'
    Properties:
      PolicyName: !Sub 
        - '${PolicyNamePrefix}OpenSearchCognitoRoleDefaultPolicy'
        - { PolicyNamePrefix: !If [UseSpecificResourcePrefix, !Ref ResourcePrefix, !Ref AWS::StackName] }
      PolicyDocument:
        Statement:
          - Action: 'iam:PassRole'
            Condition:
              StringLike:
                'iam:PassedToService': cognito-identity.amazonaws.com
            Effect: Allow
            Resource: !GetAtt OpenSearchCognitoRole.Arn
        Version: 2012-10-17
      Roles:
        - !Ref OpenSearchCognitoRole
  KinesisDeliveryStreamRole:
    Type: 'AWS::IAM::Role'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28
            reason: "Only in case a specific resource prefix is used"
    Properties:
      RoleName: !If [UseSpecificResourcePrefix, !Sub '${ResourcePrefix}KinesisDeliveryStreamRole', !Ref AWS::NoValue]
      AssumeRolePolicyDocument:
        Statement:
          - Action: 'sts:AssumeRole'
            Effect: Allow
            Principal:
              Service: firehose.amazonaws.com
        Version: 2012-10-17
  OpenSearchServiceLinkedRole:
    Type: AWS::IAM::ServiceLinkedRole
    Properties: 
      AWSServiceName: 'es.amazonaws.com'  
  GetHostedZoneId:
    Type: Custom::GetHostedZoneId
    Properties:
      ServiceToken: !GetAtt DeploymentHelper.Arn
      DnsName: !Ref CustomOpenSearchDashboardsDomain
  CustomOpenSearchDashboardsCertificate:
    Type: AWS::CertificateManager::Certificate
    Properties:
      DomainName: !Sub '${OpenSearchName}.${CustomOpenSearchDashboardsDomain}'
      ValidationMethod: DNS
      DomainValidationOptions:
        - DomainName: !Sub '${OpenSearchName}.${CustomOpenSearchDashboardsDomain}'
          HostedZoneId: !GetAtt GetHostedZoneId.HostedZoneId
  OpenSearchDomain:
    Type: 'AWS::OpenSearchService::Domain'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28
            reason: using customer provided domain name
    DependsOn:
      - OpenSearchCognitoUserPoolDomain
      - OpenSearchServiceLinkedRole
    Properties:
      DomainName: !Ref OpenSearchName
      AccessPolicies:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - 'es:ESHttpGet'
              - 'es:ESHttpDelete'
              - 'es:ESHttpPut'
              - 'es:ESHttpPost'
              - 'es:ESHttpHead'
              - 'es:ESHttpPatch'
            Principal:
              AWS: !GetAtt OpenSearchCognitoAuthenticationRole.Arn
            Resource: !Sub 'arn:${AWS::Partition}:es:${AWS::Region}:${AWS::AccountId}:domain/${OpenSearchName}/*'
          - Effect: Allow
            Action:
              - 'es:DescribeElasticsearchDomain'
              - 'es:DescribeElasticsearchDomains'
              - 'es:DescribeElasticsearchDomainConfig'
              - 'es:ESHttpPost'
              - 'es:ESHttpPut'
              - 'es:HttpGet'
            Principal:
              AWS: !GetAtt KinesisDeliveryStreamRole.Arn
            Resource: !Sub 'arn:${AWS::Partition}:es:${AWS::Region}:${AWS::AccountId}:domain/${OpenSearchName}/*'
      ClusterConfig:
        DedicatedMasterCount: !If [UseMasterNode, !FindInMap [OpenSearchSizing, MasterCount, !Ref Size], !Ref AWS::NoValue]
        DedicatedMasterEnabled: !If [UseMasterNode, true, false]
        DedicatedMasterType: !If [UseMasterNode, !FindInMap [OpenSearchSizing, MasterSize, !Ref Size], !Ref AWS::NoValue]
        InstanceCount: !FindInMap [OpenSearchSizing, NodeCount, !Ref Size]
        InstanceType: !FindInMap [OpenSearchSizing, InstanceSize, !Ref Size]
        ZoneAwarenessConfig: !If
          - UseZoneAwarenes
          - AvailabilityZoneCount: 2
          - !Ref AWS::NoValue
        ZoneAwarenessEnabled: !If [UseZoneAwarenes, true, false]
      CognitoOptions:
        Enabled: true
        IdentityPoolId: !Ref OpenSearchCognitoIdentityPool
        RoleArn: !GetAtt OpenSearchCognitoRole.Arn
        UserPoolId: !Ref OpenSearchCognitoUserPool
      DomainEndpointOptions:
        CustomEndpoint: !Sub '${OpenSearchName}.${CustomOpenSearchDashboardsDomain}'
        CustomEndpointCertificateArn: !Ref CustomOpenSearchDashboardsCertificate
        CustomEndpointEnabled: true
        EnforceHTTPS: true
        TLSSecurityPolicy: Policy-Min-TLS-1-2-2019-07
      EBSOptions:
        EBSEnabled: true
        VolumeSize: 10
        VolumeType: gp2
      EngineVersion: 'OpenSearch_1.0'
      EncryptionAtRestOptions:
        Enabled: true
      LogPublishingOptions:
        ES_APPLICATION_LOGS:
          Enabled: false
        SEARCH_SLOW_LOGS:
          Enabled: false
        INDEX_SLOW_LOGS:
          Enabled: false
      NodeToNodeEncryptionOptions:
        Enabled: true
  OpenSearchDomainDashboardRecordSet:
    Type: AWS::Route53::RecordSetGroup
    Properties:
      HostedZoneId: !GetAtt GetHostedZoneId.HostedZoneId
      RecordSets:
        - Name: !Sub '${OpenSearchName}.${CustomOpenSearchDashboardsDomain}'
          Type: CNAME
          TTL: '300'
          ResourceRecords:
            - !GetAtt OpenSearchDomain.DomainEndpoint
  OpenSearchCognitoAuthenticationRolePolicy:
    Type: 'AWS::IAM::Policy'
    Properties:
      PolicyName: !Sub 
        - '${PolicyNamePrefix}OpenSearchCognitoAuthenticationRolePolicy'
        - { PolicyNamePrefix: !If [UseSpecificResourcePrefix, !Ref ResourcePrefix, !Ref AWS::StackName] }
      PolicyDocument:
        Statement:
          - Action:
              - 'es:ESHttpGet'
              - 'es:ESHttpDelete'
              - 'es:ESHttpPut'
              - 'es:ESHttpPost'
              - 'es:ESHttpHead'
              - 'es:ESHttpPatch'
            Effect: Allow
            Resource: !GetAtt OpenSearchDomain.Arn
        Version: 2012-10-17
      Roles:
        - !Ref OpenSearchCognitoAuthenticationRole  
  KinesisDataStream:
    Type: 'AWS::Kinesis::Stream'
    Properties:
      ShardCount: 1
      RetentionPeriodHours: 24
      StreamEncryption:
        EncryptionType: KMS
        KeyId: alias/aws/kinesis
  KinesisDeliveryStreamBackupBucketAccessLogs:
    Type: 'AWS::S3::Bucket'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W35
            reason: 'access logging disabled, it is a logging bucket'
          - id: W51
            reason: permission given for log delivery
    Properties:
      BucketName: !If [UseSpecificResourcePrefix, !Sub '${ResourcePrefix}kinesisdeliverystreambackupbucketaccesslogs', !Ref AWS::NoValue]
      AccessControl: LogDeliveryWrite
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
  DeleteContentFromKinesisDeliveryStreamBackupBucketAccessLogs:
    Type: Custom::DeleteBucketContent
    Properties:
      ServiceToken: !GetAtt DeploymentHelper.Arn
      BucketName: !Ref KinesisDeliveryStreamBackupBucketAccessLogs
  KinesisDeliveryStreamBackupBucket:
    Type: 'AWS::S3::Bucket'
    Properties:
      BucketName: !If [UseSpecificResourcePrefix, !Sub '${ResourcePrefix}kinesisdeliverystreambackupbucket', !Ref AWS::NoValue]
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      LoggingConfiguration:
        DestinationBucketName: !Ref KinesisDeliveryStreamBackupBucketAccessLogs
        LogFilePrefix: os-access-logs
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
  DeleteContentFromKinesisDeliveryStreamBackupBucket:
    Type: Custom::DeleteBucketContent
    Properties:
      ServiceToken: !GetAtt DeploymentHelper.Arn
      BucketName: !Ref KinesisDeliveryStreamBackupBucket
  LogDataTransformerLambdaRole:
    Type: 'AWS::IAM::Role'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28
            reason: "Only in case a specific resource prefix is used"
    Properties:
      RoleName: !If [UseSpecificResourcePrefix, !Sub '${ResourcePrefix}LogDataTransformerLambdaRole', !Ref AWS::NoValue]
      AssumeRolePolicyDocument:
        Statement:
          - Action: 'sts:AssumeRole'
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
        Version: 2012-10-17
      ManagedPolicyArns:
        - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
  LogDataTransformerLambdaRolePolicy:
    Type: 'AWS::IAM::Policy'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W12
            reason: "Affected actions apply to all resources"
    Properties:
      PolicyName: !Sub 
        - '${PolicyNamePrefix}LogDataTransformerLambdaRolePolicy'
        - { PolicyNamePrefix: !If [UseSpecificResourcePrefix, !Ref ResourcePrefix, !Ref AWS::StackName] }
      PolicyDocument:
        Statement:
          - Action:
              - 'kinesis:DescribeStream'
              - 'kinesis:DescribeStreamSummary'
              - 'kinesis:GetRecords'
              - 'kinesis:GetShardIterator'
              - 'kinesis:SubscribeToShard'
            Effect: Allow
            Resource:  !GetAtt KinesisDataStream.Arn
          - Action:
              - 'kinesis:ListStreams'
              - 'kinesis:ListShards'
            Effect: Allow
            Resource:  '*'
          - Action: 'firehose:PutRecordBatch'
            Effect: Allow
            Resource: !GetAtt KinesisDeliveryStream.Arn
        Version: 2012-10-17
      Roles:
        - !Ref LogDataTransformerLambdaRole
  LogDataTransformerLambda:
    Type: 'AWS::Lambda::Function'
    Metadata:
      cfn-lint:
        config:
          ignore_checks:
            - E3002
      cfn_nag:
        rules_to_suppress:
          - id: W58
            reason: "Provided by managed policy AWSLambdaBasicExecutionRole in LogDataTransformerLambdaRole"
          - id: W89
            reason: "No need for VPC here"
          - id: W92
            reason: "No concurrency needed"
    DependsOn:
      - LogDataTransformerLambdaRolePolicy
    Properties: 
      FunctionName: !Sub 
        - '${FunctionNamePrefix}LogDataTransformerLambda'
        - { FunctionNamePrefix: !If [UseSpecificResourcePrefix, !Ref ResourcePrefix, !Ref AWS::StackName] }
      Architectures: 
        - arm64
      Code: 
        ZipFile: |          
          import json, boto3, logging, base64, gzip, os
          from io import BytesIO
          from datetime import datetime

          levels = {
              'critical': logging.CRITICAL,
              'error': logging.ERROR,
              'warn': logging.WARNING,
              'info': logging.INFO,
              'debug': logging.DEBUG
          }
          logger = logging.getLogger()
          try:   
              logger.setLevel(levels.get(os.getenv('LOG_LEVEL', 'info').lower()))
          except KeyError as e:
              logger.setLevel(logging.INFO)

          def transformLogEvent(logEvent, owner, logGroup, logStream):
              rV = {}
              rV['timestamp'] = datetime.fromtimestamp(logEvent['timestamp']/1000.0).isoformat();
              rV['id'] = logEvent['id'];
              rV['type'] = "CloudWatchLogs";
              rV['@message'] = logEvent['message']
              rV['@owner'] = owner
              rV['@log_group'] = logGroup
              rV['@log_stream'] = logStream
              return rV

          def createRecordsFromLogEvents(logEvents, owner, logGroup, logStream):
              rV = []
              for logEvent in logEvents:
                  transformedLogEvent = transformLogEvent(logEvent, owner, logGroup, logStream)
                  dataBytes = json.dumps(transformedLogEvent).encode("utf-8")
                  rV.append({"Data": dataBytes})
              return rV

          def putRecordsToFirehoseStream(streamName, records, client, attemptsMade, maxAttempts):
              failedRecords = []
              codes = []
              errMsg = ''
              response = None
              try:
                  response = client.put_record_batch(DeliveryStreamName=streamName, Records=records)
              except Exception as e:
                  failedRecords = records
                  errMsg = str(e)

              if not failedRecords and response and response['FailedPutCount'] > 0:
                  for idx, res in enumerate(response['RequestResponses']):            
                      if 'ErrorCode' not in res or not res['ErrorCode']:
                          continue

                      codes.append(res['ErrorCode'])
                      failedRecords.append(records[idx])

                  errMsg = f"Individual error codes: {','.join(codes)}"

              if len(failedRecords) > 0:
                  if attemptsMade + 1 < maxAttempts:
                      logger.warn(f"Some records failed while calling PutRecordBatch to Firehose stream, retrying. {errMsg}")
                      putRecordsToFirehoseStream(streamName, failedRecords, client, attemptsMade + 1, maxAttempts)
                  else:
                      msg = f"Could not put records after {str(maxAttempts)} attempts. {errMsg}"
                      logger.error(msg)
                      raise RuntimeError(msg)

          def processRecords(records, client, streamName):
              rV = []
              for r in records:
                  data = base64.b64decode(r['kinesis']['data'])
                  striodata = BytesIO(data)
                  with gzip.GzipFile(fileobj=striodata, mode='r') as f:
                      data = json.loads(f.read())

                  logger.debug(f"data: {data}")
                  if data['messageType'] == 'DATA_MESSAGE':
                      firehoseRecords = createRecordsFromLogEvents(data['logEvents'], data['owner'], data['logGroup'], data['logStream'])
                      logger.debug(f"firehoseRecords: {firehoseRecords}")
                      rV.append(firehoseRecords)
                      putRecordsToFirehoseStream(streamName, firehoseRecords, client, attemptsMade=0, maxAttempts=20)

              return rV

          def lambda_handler(event, context):
              logger.debug(f"Event: {event}")
              logger.info(f"Start processing event records.")
              streamName = os.environ['DATA_STREAM_NAME']
              client = boto3.client('firehose')
              records = processRecords(event['Records'], client, streamName)
              logger.info(f"Finished processing event records.")    
              logger.debug(f"Records: {records}")
      Description: Log Data Transformation function
      Handler: "index.lambda_handler"
      Runtime: python3.8
      MemorySize: 128
      Timeout: 300
      Role: !GetAtt LogDataTransformerLambdaRole.Arn
      Environment:
        Variables:
          LOG_LEVEL: info
          DATA_STREAM_NAME: !Ref KinesisDeliveryStream
  LogDataTransformerKinesisEventSource:
    Type: 'AWS::Lambda::EventSourceMapping'
    Properties:
      EventSourceArn: !GetAtt KinesisDataStream.Arn
      FunctionName: !Ref LogDataTransformerLambda
      BatchSize: 100
      StartingPosition: TRIM_HORIZON
  KinesisDeliveryStreamBackupBucketPolicy:
    Type: 'AWS::S3::BucketPolicy'
    Properties:
      Bucket: !Ref KinesisDeliveryStreamBackupBucket
      PolicyDocument:
        Statement:
          - Action:
              - 's3:Put*'
              - 's3:Get*'
            Effect: Allow
            Principal:
              AWS: !GetAtt KinesisDeliveryStreamRole.Arn
            Resource:
              - !Sub '${KinesisDeliveryStreamBackupBucket.Arn}'
              - !Sub '${KinesisDeliveryStreamBackupBucket.Arn}/*'
        Version: 2012-10-17
  KinesisDeliveryStreamLogGroup:
    Type: 'AWS::Logs::LogGroup'
    Properties:
      LogGroupName: !Sub 
        - '/aws/kinesisfirehose/${LogGroupNamePrefix}KinesisDeliveryStream'
        - { LogGroupNamePrefix: !If [UseSpecificResourcePrefix, !Ref ResourcePrefix, !Ref AWS::StackName] }
      RetentionInDays: 30
  KinesisDeliveryStreamOpenSearchDeliveryLogStream:
    Type: 'AWS::Logs::LogStream'
    Properties:
      LogGroupName: !Ref KinesisDeliveryStreamLogGroup
      LogStreamName: OpenSearchDelivery  
  KinesisDeliveryStreamS3DeliveryLogStream:
    Type: 'AWS::Logs::LogStream'
    Properties:
      LogGroupName: !Ref KinesisDeliveryStreamLogGroup
      LogStreamName: S3Delivery
  KinesisDeliveryStreamPolicy:
    Type: 'AWS::IAM::Policy'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W12
            reason: '* needed for actions that do no support resource level permissions'
          - id: W76
            reason: policy verified
    Properties:
      PolicyName: !Sub 
        - '${PolicyNamePrefix}KinesisDeliveryStreamPolicy'
        - { PolicyNamePrefix: !If [UseSpecificResourcePrefix, !Ref ResourcePrefix, !Ref AWS::StackName] }
      PolicyDocument:
        Statement:
          - Action:
              - 's3:AbortMultipartUpload'
              - 's3:GetBucketLocation'
              - 's3:GetObject'
              - 's3:ListBucket'
              - 's3:ListBucketMultipartUploads'
              - 's3:ListBucketMultipartUploads'
            Effect: Allow
            Resource: 
              - !Sub '${KinesisDeliveryStreamBackupBucket.Arn}'
              - !Sub '${KinesisDeliveryStreamBackupBucket.Arn}/*'
          - Action:
              - 'ec2:DescribeVpcs'
              - 'ec2:DescribeVpcAttribute'
              - 'ec2:DescribeSubnets'
              - 'ec2:DescribeSecurityGroups'
              - 'ec2:DescribeNetworkInterfaces'
              - 'ec2:CreateNetworkInterface'
              - 'ec2:CreateNetworkInterfacePermission'
              - 'ec2:DeleteNetworkInterface'
            Effect: Allow
            Resource: '*'
          - Action:
              - 'es:DescribeElasticsearchDomain'
              - 'es:DescribeElasticsearchDomains'
              - 'es:DescribeElasticsearchDomainConfig'
              - 'es:ESHttpPost'
              - 'es:ESHttpPut'
            Effect: Allow
            Resource: 
              - !Sub 'arn:${AWS::Partition}:es:${AWS::Region}:${AWS::AccountId}:domain/${OpenSearchDomain}'
              - !Sub 'arn:${AWS::Partition}:es:${AWS::Region}:${AWS::AccountId}:domain/${OpenSearchDomain}/*'
          - Action: 'es:ESHttpGet'
            Effect: Allow
            Resource:
              - !Sub 'arn:${AWS::Partition}:es:${AWS::Region}:${AWS::AccountId}:domain/${OpenSearchDomain}/_all/_settings'
              - !Sub 'arn:${AWS::Partition}:es:${AWS::Region}:${AWS::AccountId}:domain/${OpenSearchDomain}/_cluster/stats'
              - !Sub 'arn:${AWS::Partition}:es:${AWS::Region}:${AWS::AccountId}:domain/${OpenSearchDomain}/${OpenSearchIndexName}/_mapping/kinesis'
              - !Sub 'arn:${AWS::Partition}:es:${AWS::Region}:${AWS::AccountId}:domain/${OpenSearchDomain}/_nodes'
              - !Sub 'arn:${AWS::Partition}:es:${AWS::Region}:${AWS::AccountId}:domain/${OpenSearchDomain}/_nodes/*/stats'
              - !Sub 'arn:${AWS::Partition}:es:${AWS::Region}:${AWS::AccountId}:domain/${OpenSearchDomain}/_stats'
              - !Sub 'arn:${AWS::Partition}:es:${AWS::Region}:${AWS::AccountId}:domain/${OpenSearchDomain}/${OpenSearchIndexName}/_stats'
          - Action:
              - 'logs:PutLogEvents'
              - 'logs:CreateLogStream'
            Effect: Allow
            Resource: !GetAtt KinesisDeliveryStreamLogGroup.Arn
          - Action: 
              - 'kms:GenerateDataKey'
              - 'kms:Decrypt'
            Condition:
              StringEquals:
                'kms:ViaService': !Sub 's3.${AWS::Region}.amazonaws.com'
              StringLike:
                'kms:EncryptionContext:aws:s3:arn': !Sub '${KinesisDeliveryStreamBackupBucket.Arn}/*'
            Effect: Allow
            Resource: !Sub 'arn:${AWS::Partition}:kms:${AWS::Region}:${AWS::AccountId}:key/*'
          - Action: 
              - 'kms:GenerateDataKey'
              - 'kms:Decrypt'
            Condition:
              StringEquals:
                'kms:ViaService': !Sub 'kinesis.${AWS::Region}.amazonaws.com'
              StringLike:
                'kms:EncryptionContext:aws:kinesis:arn': !GetAtt KinesisDataStream.Arn
            Effect: Allow
            Resource: !Sub 'arn:${AWS::Partition}:kms:${AWS::Region}:${AWS::AccountId}:key/*'
        Version: 2012-10-17
      Roles:
        - !Ref KinesisDeliveryStreamRole
  KinesisDeliveryStream:
    Type: 'AWS::KinesisFirehose::DeliveryStream'
    DependsOn:
      - KinesisDeliveryStreamPolicy
    Properties:
      DeliveryStreamEncryptionConfigurationInput:
        KeyType: AWS_OWNED_CMK
      DeliveryStreamName: OpenSearch-Firehose
      DeliveryStreamType: DirectPut
      ElasticsearchDestinationConfiguration:
        CloudWatchLoggingOptions:
          Enabled: true
          LogGroupName: !Sub 
            - '/aws/kinesisfirehose/${LogGroupNamePrefix}KinesisDeliveryStream'
            - { LogGroupNamePrefix: !If [UseSpecificResourcePrefix, !Ref ResourcePrefix, !Ref AWS::StackName] }
          LogStreamName: !Ref KinesisDeliveryStreamOpenSearchDeliveryLogStream
        DomainARN: !GetAtt OpenSearchDomain.Arn
        IndexName: !Ref OpenSearchIndexName
        IndexRotationPeriod: OneDay
        RoleARN: !GetAtt KinesisDeliveryStreamRole.Arn
        S3BackupMode: AllDocuments
        S3Configuration:
          BucketARN: !GetAtt KinesisDeliveryStreamBackupBucket.Arn
          CloudWatchLoggingOptions:
            Enabled: true
            LogGroupName: !Sub 
              - '/aws/kinesisfirehose/${LogGroupNamePrefix}KinesisDeliveryStream'
              - { LogGroupNamePrefix: !If [UseSpecificResourcePrefix, !Ref ResourcePrefix, !Ref AWS::StackName] }
            LogStreamName: !Ref KinesisDeliveryStreamS3DeliveryLogStream
          RoleARN: !GetAtt KinesisDeliveryStreamRole.Arn
  CloudWatchDestinationRole:
    Type: 'AWS::IAM::Role'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28
            reason: "Only in case a specific resource prefix is used"
    Properties:
      RoleName: !If [UseSpecificResourcePrefix, !Sub '${ResourcePrefix}CloudWatchDestinationRole', !Ref AWS::NoValue]
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: logs.amazonaws.com
            Action: 'sts:AssumeRole'
        Version: 2012-10-17
  CloudWatchDestinationRolePolicy:
    Type: 'AWS::IAM::Policy'
    Properties:
      PolicyName: !Sub 
        - '${PolicyNamePrefix}CloudWatchDestinationRolePolicy'
        - { PolicyNamePrefix: !If [UseSpecificResourcePrefix, !Ref ResourcePrefix, !Ref AWS::StackName] }
      PolicyDocument:
        Statement:
          - Action: 'kinesis:PutRecord'
            Effect: Allow
            Resource: !GetAtt KinesisDataStream.Arn
        Version: 2012-10-17
      Roles:
        - !Ref CloudWatchDestinationRole
  DeploymentHelperAdditionalRolePolicy:
    Type: 'AWS::IAM::Policy'
    Properties:
      PolicyName: !Sub 
        - '${PolicyNamePrefix}DeploymentHelperAdditionalRolePolicy'
        - { PolicyNamePrefix: !If [UseSpecificResourcePrefix, !Ref ResourcePrefix, !Ref AWS::StackName] }
      PolicyDocument:
        Statement:
          - Action: 'iam:PassRole'
            Effect: Allow
            Resource: !GetAtt CloudWatchDestinationRole.Arn
        Version: 2012-10-17
      Roles:
        - !Ref DeploymentHelperRole
    DependsOn:
      - CloudWatchDestinationRolePolicy
  CloudWatchDestination:
    Type: 'Custom::CloudWatchDestination'
    DependsOn:
      - DeploymentHelperAdditionalRolePolicy
    Properties:
      ServiceToken: !GetAtt DeploymentHelper.Arn
      Regions: !Split [",", !Ref SpokeRegions]
      DestinationName: !Ref DestinationName
      RoleArn: !GetAtt CloudWatchDestinationRole.Arn
      DataStreamArn: !GetAtt KinesisDataStream.Arn
      SpokeAccounts: !Split [",", !If [UseCurrentAccount, !Ref AWS::AccountId, !Ref SpokeAccounts]]
Outputs:
  DestinationSubscriptionArn:
    Description: Arn of Destination to be created for each relevant LogGroup in the spoke accounts
    Value: !Sub 'arn:${AWS::Partition}:logs:<region>:${AWS::AccountId}:destination:${DestinationName}'
  GuiUrl:
    Description: The URL for accessing the GUI of OpenSearch
    Value: !Sub 'https://${OpenSearchName}.${CustomOpenSearchDashboardsDomain}/_dashboards'